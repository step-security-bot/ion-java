<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WriteBuffer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">com.amazon.ion.impl.bin</a> &gt; <span class="el_source">WriteBuffer.java</span></div><h1>WriteBuffer.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2007-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed
 * on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazon.ion.impl.bin;

import java.io.Closeable;
import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.List;

/**
 * A facade over {@link Block} management and low-level Ion encoding concerns for the {@link IonRawBinaryWriter}.
 */
<span class="pc bpc" id="L27" title="1 of 2 branches missed.">/*package*/ final class WriteBuffer implements Closeable</span>
{
    private final BlockAllocator allocator;
    private final List&lt;Block&gt; blocks;
    private Block current;
    private int index;

    public WriteBuffer(final BlockAllocator allocator)
<span class="fc" id="L35">    {</span>
<span class="fc" id="L36">        this.allocator = allocator;</span>
<span class="fc" id="L37">        this.blocks = new ArrayList&lt;Block&gt;();</span>

        // initial seed of the first block
<span class="fc" id="L40">        allocateNewBlock();</span>

<span class="fc" id="L42">        this.index = 0;</span>
<span class="fc" id="L43">        this.current = blocks.get(0);</span>
<span class="fc" id="L44">    }</span>

    private void allocateNewBlock()
    {
<span class="fc" id="L48">        blocks.add(allocator.allocateBlock());</span>
<span class="fc" id="L49">    }</span>

    /** Returns the block index for the given position. */
    private int index(final long position)
    {
<span class="fc" id="L54">        return (int) (position / allocator.getBlockSize());</span>
    }

    /** Returns the offset within the block for a given position. */
    private int offset(final long position)
    {
<span class="fc" id="L60">        return (int) (position % allocator.getBlockSize());</span>
    }

    /** Resets the write buffer to empty. */
    public void reset()
    {
<span class="fc" id="L66">        close();</span>
<span class="fc" id="L67">        allocateNewBlock();</span>
<span class="fc" id="L68">        index = 0;</span>
<span class="fc" id="L69">        current = blocks.get(index);</span>
<span class="fc" id="L70">    }</span>

    public void close()
    {
        // free all the blocks
<span class="fc bfc" id="L75" title="All 2 branches covered.">        for (final Block block : blocks)</span>
        {
<span class="fc" id="L77">            block.close();</span>
<span class="fc" id="L78">        }</span>
<span class="fc" id="L79">        blocks.clear();</span>

        // note--we don't explicitly flag that we're closed for efficiency
<span class="fc" id="L82">    }</span>

    /** Resets the write buffer to a particular point. */
    public void truncate(final long position)
    {
<span class="fc" id="L87">        final int index = index(position);</span>
<span class="fc" id="L88">        final int offset = offset(position);</span>
<span class="fc" id="L89">        final Block block = blocks.get(index);</span>
<span class="fc" id="L90">        this.index = index;</span>
<span class="fc" id="L91">        block.limit = offset;</span>
<span class="fc" id="L92">        current = block;</span>
<span class="fc" id="L93">    }</span>

    /** Returns the amount of capacity left in the current block. */
    public int remaining()
    {
<span class="fc" id="L98">        return current.remaining();</span>
    }

    /** Returns the logical position in the current block. */
    public long position()
    {
<span class="fc" id="L104">        return (((long) index) * allocator.getBlockSize()) + current.limit;</span>
    }

    private static final int OCTET_MASK = 0xFF;

    /** Returns the octet at the logical position given. */
    public int getUInt8At(final long position)
    {
<span class="fc" id="L112">        final int index = index(position);</span>
<span class="fc" id="L113">        final int offset = offset(position);</span>
<span class="fc" id="L114">        final Block block = blocks.get(index);</span>
<span class="fc" id="L115">        return block.data[offset] &amp; OCTET_MASK;</span>
    }

    /** Writes a single octet to the buffer, expanding if necessary. */
    public void writeByte(final byte octet)
    {
<span class="fc bfc" id="L121" title="All 2 branches covered.">        if (remaining() &lt; 1)</span>
        {
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">            if (index == blocks.size() - 1)</span>
            {
<span class="fc" id="L125">                allocateNewBlock();</span>
            }
<span class="fc" id="L127">            index++;</span>
<span class="fc" id="L128">            current = blocks.get(index);</span>
        }
<span class="fc" id="L130">        final Block block = current;</span>
<span class="fc" id="L131">        block.data[block.limit] = octet;</span>
<span class="fc" id="L132">        block.limit++;</span>
<span class="fc" id="L133">    }</span>

    // slow in the sense that we do all kind of block boundary checking
    private void writeBytesSlow(final byte[] bytes, int off, int len)
    {
<span class="fc bfc" id="L138" title="All 2 branches covered.">        while (len &gt; 0)</span>
        {
<span class="fc" id="L140">            final Block block = current;</span>
<span class="fc" id="L141">            final int amount = Math.min(len, block.remaining());</span>
<span class="fc" id="L142">            System.arraycopy(bytes, off, block.data, block.limit, amount);</span>
<span class="fc" id="L143">            block.limit += amount;</span>
<span class="fc" id="L144">            off += amount;</span>
<span class="fc" id="L145">            len -= amount;</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">            if (block.remaining() == 0)</span>
            {
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">                if (index == blocks.size() - 1)</span>
                {
<span class="fc" id="L150">                    allocateNewBlock();</span>
                }
<span class="fc" id="L152">                index++;</span>
<span class="fc" id="L153">                current = blocks.get(index);</span>
            }
<span class="fc" id="L155">        }</span>

<span class="fc" id="L157">    }</span>

    /** Writes an array of bytes to the buffer expanding if necessary. */
    public void writeBytes(final byte[] bytes, final int off, final int len)
    {
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (len &gt; remaining())</span>
        {
<span class="fc" id="L164">            writeBytesSlow(bytes, off, len);</span>
<span class="fc" id="L165">            return;</span>
        }

<span class="fc" id="L168">        final Block block = current;</span>
<span class="fc" id="L169">        System.arraycopy(bytes, off, block.data, block.limit, len);</span>
<span class="fc" id="L170">        block.limit += len;</span>
<span class="fc" id="L171">    }</span>

    /**
     * Shifts the last `length` bytes in the buffer to the left. This can be used when a value's header was
     * preallocated but the value's encoded size proved to be much smaller than anticipated.
     *
     * The caller must guarantee that the buffer contains enough bytes to perform the requested shift.
     *
     * @param length    The number of bytes at the end of the buffer that we'll be shifting to the left.
     * @param shiftBy   The number of bytes to the left that we'll be shifting.
     */
    public void shiftBytesLeft(int length, int shiftBy) {
<span class="fc bfc" id="L183" title="All 4 branches covered.">        if (length == 0 || shiftBy == 0) {</span>
            // Nothing to do.
<span class="fc" id="L185">            return;</span>
        }

        // If all of the bytes that we need to shift are in the current block, do a simple memcpy.
<span class="fc bfc" id="L189" title="All 2 branches covered.">        if (current.limit &gt;= length + shiftBy) {</span>
<span class="fc" id="L190">            shiftBytesLeftWithinASingleBlock(length, shiftBy);</span>
<span class="fc" id="L191">            return;</span>
        }

        // Otherwise, the slice we're shifting straddles multiple blocks. We'll need to iterate across those blocks
        // applying shifting logic to each one.
<span class="fc" id="L196">        shiftBytesLeftAcrossBlocks(length, shiftBy);</span>
<span class="fc" id="L197">    }</span>

    /**
     * Shifts the last `length` bytes in the buffer to the left. The caller must guarantee that the `current` Block
     * contains at least `length + shiftBy` bytes. This ensures that we're shifting a contiguous slice of bytes within
     * a single block.
     *
     * @param length    The number of bytes at the end of the buffer that we'll be shifting to the left.
     * @param shiftBy   The number of bytes to the left that we'll be shifting.
     */
    private void shiftBytesLeftWithinASingleBlock(int length, int shiftBy) {
<span class="fc" id="L208">        int startOfSliceToShift = current.limit - length;</span>
<span class="fc" id="L209">        System.arraycopy(</span>
                current.data,
                startOfSliceToShift,
                current.data,
                startOfSliceToShift - shiftBy,
                length
        );
        // Update the `limit` (cursor position) within the current block to reflect that
        // we have reclaimed `length` bytes of space in the buffer.
<span class="fc" id="L218">        current.limit -= shiftBy;</span>
<span class="fc" id="L219">    }</span>

    /**
     * Shifts the last `length` bytes in the buffer to the left. Unlike
     * {@link #shiftBytesLeftWithinASingleBlock(int, int)}, this method supports shifting bytes across multiple blocks
     * in the buffer.
     *
     * @param length    The number of bytes at the end of the buffer that we'll be shifting to the left.
     * @param shiftBy   The number of bytes to the left that we'll be shifting.
     */
    private void shiftBytesLeftAcrossBlocks(int length, int shiftBy) {
        // In this method, &quot;buffer offsets&quot; are absolute indexes into the WriteBuffer and
        // &quot;block offsets&quot; are indexes that are relative to the beginning of the current Block.

        // The first buffer offset that does not yet contain data.
<span class="fc" id="L234">        long position = position();</span>
        // This is the buffer offset of the first byte that we will be shifting backwards.
<span class="fc" id="L236">        long sourceBufferOffset = position - length;</span>
        // When we're done, this will be the first offset in the buffer that does not contain data.
<span class="fc" id="L238">        long writeBufferLimit = position - shiftBy;</span>

<span class="fc bfc" id="L240" title="All 2 branches covered.">        while (length &gt; 0) {</span>
            // Convert the source buffer offset into a (Block, block offset) pair.
<span class="fc" id="L242">            int sourceBlockIndex = index(sourceBufferOffset);</span>
<span class="fc" id="L243">            Block sourceBlock = blocks.get(sourceBlockIndex);</span>
<span class="fc" id="L244">            int sourceBlockOffset = offset(sourceBufferOffset);</span>

            // Convert the destination buffer offset into a (Block, block offset) pair.
            // Because buffer offsets are absolute, the `destinationBufferOffset` in each loop iteration is
            // `shiftBy` positions behind the `sourceBufferOffset`.
<span class="fc" id="L249">            long destinationBufferOffset = sourceBufferOffset - shiftBy;</span>
<span class="fc" id="L250">            int destinationBlockIndex = index(destinationBufferOffset);</span>
<span class="fc" id="L251">            Block destinationBlock = blocks.get(destinationBlockIndex);</span>
<span class="fc" id="L252">            int destinationBlockOffset = offset(destinationBufferOffset);</span>

            // Determine how many bytes are left in the source and destination blocks following their respective
            // block offsets.
<span class="fc" id="L256">            int bytesLeftInSourceBlock = sourceBlock.limit - sourceBlockOffset;</span>
<span class="fc" id="L257">            int bytesLeftInDestinationBlock = destinationBlock.limit - destinationBlockOffset;</span>
            // Whichever block has fewer bytes remaining will determine how many bytes we consider to be
            // available for shifting in this pass.
<span class="fc" id="L260">            int bytesAvailableToCopy = Math.min(bytesLeftInSourceBlock, bytesLeftInDestinationBlock);</span>

            // If there are more bytes available than we need to finish the shifting operation, take `length` instead.
<span class="fc" id="L263">            int numberOfBytesToShift = Math.min(length, bytesAvailableToCopy);</span>

            // Copy the bytes from the source to the destination.
<span class="fc" id="L266">            System.arraycopy(</span>
                    sourceBlock.data,
                    sourceBlockOffset,
                    destinationBlock.data,
                    destinationBlockOffset,
                    numberOfBytesToShift
            );

            // Update our record of how many bytes to shift remain...
<span class="fc" id="L275">            length -= numberOfBytesToShift;</span>
            // ...and from which point we should resume in the next iteration.
<span class="fc" id="L277">            sourceBufferOffset += numberOfBytesToShift;</span>
<span class="fc" id="L278">        }</span>

        // At this point, the shifting is complete. However, we have reclaimed some amount of space in the WriteBuffer.
        // Using the `writeBufferLimit` we calculated at the beginning of the method, find the last Block that still
        // contains data.
<span class="fc" id="L283">        int lastBlockIndex = index(writeBufferLimit);</span>
<span class="fc" id="L284">        Block lastBlock = blocks.get(lastBlockIndex);</span>
<span class="fc" id="L285">        int lastBlockOffset = offset(writeBufferLimit);</span>

        // Update that Block's limit...
<span class="fc" id="L288">        lastBlock.limit = lastBlockOffset;</span>
        // ...and return any empty blocks at the tail of the `blocks` list to the pool.
<span class="fc bfc" id="L290" title="All 2 branches covered.">        for (int m = blocks.size() - 1; m &gt; lastBlockIndex; m--) {</span>
<span class="fc" id="L291">            Block emptyBlock = blocks.remove(m);</span>
<span class="fc" id="L292">            emptyBlock.close();</span>
        }

        // Update the WriteBuffer's member fields to reflect the changes we've made.
<span class="fc" id="L296">        current = lastBlock;</span>
<span class="fc" id="L297">        index = lastBlockIndex;</span>
<span class="fc" id="L298">    }</span>

    /** Writes an array of bytes to the buffer expanding if necessary, defaulting to the entire array. */
    public void writeBytes(byte[] bytes)
    {
<span class="fc" id="L303">        writeBytes(bytes, 0, bytes.length);</span>
<span class="fc" id="L304">    }</span>

    // UTF-8 character writing

    private static final char HIGH_SURROGATE_FIRST      = 0xD800;
    private static final char HIGH_SURROGATE_LAST       = 0xDBFF;
    private static final char LOW_SURROGATE_FIRST       = 0xDC00;
    private static final char LOW_SURROGATE_LAST        = 0xDFFF;
    private static final int  SURROGATE_BASE            = 0x10000;
    private static final int  BITS_PER_SURROGATE        = 10;

    private static final int  UTF8_FOLLOW_MASK          = 0x3F;

    private static final int  UTF8_FOLLOW_PREFIX_MASK   = 0x80;
    private static final int  UTF8_2_OCTET_PREFIX_MASK  = 0xC0;
    private static final int  UTF8_3_OCTET_PREFIX_MASK  = 0xE0;
    private static final int  UTF8_4_OCTET_PREFIX_MASK  = 0xF0;

    private static final int  UTF8_BITS_PER_FOLLOW_OCTET = 6;
    private static final int  UTF8_2_OCTET_SHIFT         = 1 * UTF8_BITS_PER_FOLLOW_OCTET;
    private static final int  UTF8_3_OCTET_SHIFT         = 2 * UTF8_BITS_PER_FOLLOW_OCTET;
    private static final int  UTF8_4_OCTET_SHIFT         = 3 * UTF8_BITS_PER_FOLLOW_OCTET;

    private static final int UTF8_2_OCTET_MIN_VALUE = 1 &lt;&lt; 7;
    private static final int UTF8_3_OCTET_MIN_VALUE = 1 &lt;&lt; (5 + (1 * UTF8_BITS_PER_FOLLOW_OCTET));


    // slow in the sense that we deal with any kind of UTF-8 sequence and block boundaries
    private int writeUTF8Slow(final CharSequence chars, int off, int len)
    {
<span class="fc" id="L334">        int octets = 0;</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">        while (len &gt; 0)</span>
        {
<span class="fc" id="L337">            final char ch = chars.charAt(off);</span>
<span class="pc bpc" id="L338" title="1 of 4 branches missed.">            if (ch &gt;= LOW_SURROGATE_FIRST &amp;&amp; ch &lt;= LOW_SURROGATE_LAST)</span>
            {
<span class="fc" id="L340">                throw new IllegalArgumentException(&quot;Unpaired low surrogate: &quot; + (int) ch);</span>
            }
<span class="pc bpc" id="L342" title="1 of 4 branches missed.">            if ((ch &gt;= HIGH_SURROGATE_FIRST &amp;&amp; ch &lt;= HIGH_SURROGATE_LAST))</span>
            {
                // we need to look ahead in this case
<span class="fc" id="L345">                off++;</span>
<span class="fc" id="L346">                len--;</span>
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">                if (len == 0)</span>
                {
<span class="nc" id="L349">                    throw new IllegalArgumentException(&quot;Unpaired low surrogate at end of character sequence: &quot; + ch);</span>
                }

<span class="fc" id="L352">                final int ch2 = chars.charAt(off);</span>
<span class="pc bpc" id="L353" title="1 of 4 branches missed.">                if (ch2 &lt; LOW_SURROGATE_FIRST || ch2 &gt; LOW_SURROGATE_LAST)</span>
                {
<span class="fc" id="L355">                    throw new IllegalArgumentException(&quot;Low surrogate with unpaired high surrogate: &quot; + ch + &quot; + &quot; + ch2);</span>
                }

                // at this point we have a high and low surrogate
<span class="fc" id="L359">                final int codepoint = (((ch - HIGH_SURROGATE_FIRST) &lt;&lt; BITS_PER_SURROGATE) | (ch2 - LOW_SURROGATE_FIRST)) + SURROGATE_BASE;</span>
<span class="fc" id="L360">                writeByte((byte) (UTF8_4_OCTET_PREFIX_MASK | ( codepoint &gt;&gt; UTF8_4_OCTET_SHIFT)                    ));</span>
<span class="fc" id="L361">                writeByte((byte) (UTF8_FOLLOW_PREFIX_MASK  | ((codepoint &gt;&gt; UTF8_3_OCTET_SHIFT) &amp; UTF8_FOLLOW_MASK)));</span>
<span class="fc" id="L362">                writeByte((byte) (UTF8_FOLLOW_PREFIX_MASK  | ((codepoint &gt;&gt; UTF8_2_OCTET_SHIFT) &amp; UTF8_FOLLOW_MASK)));</span>
<span class="fc" id="L363">                writeByte((byte) (UTF8_FOLLOW_PREFIX_MASK  | ( codepoint                        &amp; UTF8_FOLLOW_MASK)));</span>

<span class="fc" id="L365">                octets += 4;</span>
<span class="fc" id="L366">            }</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">            else if (ch &lt; UTF8_2_OCTET_MIN_VALUE)</span>
            {
<span class="fc" id="L369">                writeByte((byte) ch);</span>
<span class="fc" id="L370">                octets++;</span>
            }
<span class="fc bfc" id="L372" title="All 2 branches covered.">            else if (ch &lt; UTF8_3_OCTET_MIN_VALUE)</span>
            {
<span class="fc" id="L374">                writeByte((byte) (UTF8_2_OCTET_PREFIX_MASK | (ch &gt;&gt; UTF8_2_OCTET_SHIFT)                    ));</span>
<span class="fc" id="L375">                writeByte((byte) (UTF8_FOLLOW_PREFIX_MASK  | (ch                        &amp; UTF8_FOLLOW_MASK)));</span>
<span class="fc" id="L376">                octets += 2;</span>
            }
            else
            {
<span class="fc" id="L380">                writeByte((byte) (UTF8_3_OCTET_PREFIX_MASK | ( ch &gt;&gt; UTF8_3_OCTET_SHIFT)                    ));</span>
<span class="fc" id="L381">                writeByte((byte) (UTF8_FOLLOW_PREFIX_MASK  | ((ch &gt;&gt; UTF8_2_OCTET_SHIFT) &amp; UTF8_FOLLOW_MASK)));</span>
<span class="fc" id="L382">                writeByte((byte) (UTF8_FOLLOW_PREFIX_MASK  | ( ch                        &amp; UTF8_FOLLOW_MASK)));</span>
<span class="fc" id="L383">                octets += 3;</span>
            }
<span class="fc" id="L385">            off++;</span>
<span class="fc" id="L386">            len--;</span>
<span class="fc" id="L387">        }</span>
<span class="fc" id="L388">        return octets;</span>
    }

    private int writeUTF8UpTo3Byte(final CharSequence chars, int off, int len)
    {
        // fast path if we fit in the block assuming optimistically for all three-byte
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">        if ((len * 3) &gt; remaining())</span>
        {
<span class="nc" id="L396">            return writeUTF8Slow(chars, off, len);</span>
        }

<span class="fc" id="L399">        final Block block = current;</span>
<span class="fc" id="L400">        int limit = block.limit;</span>
<span class="fc" id="L401">        int octets = 0;</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">        while (len &gt; 0)</span>
        {
<span class="fc" id="L404">            final char ch = chars.charAt(off);</span>
<span class="pc bpc" id="L405" title="3 of 4 branches missed.">            if (ch &gt;= LOW_SURROGATE_FIRST &amp;&amp; ch &lt;= LOW_SURROGATE_LAST)</span>
            {
<span class="nc" id="L407">                throw new IllegalArgumentException(&quot;Unpaired low surrogate: &quot; + ch);</span>
            }
<span class="pc bpc" id="L409" title="1 of 4 branches missed.">            if ((ch &gt;= HIGH_SURROGATE_FIRST &amp;&amp; ch &lt;= HIGH_SURROGATE_LAST))</span>
            {
                // we lost the 3-byte bet
<span class="fc" id="L412">                break;</span>
            }

<span class="pc bpc" id="L415" title="1 of 2 branches missed.">            if (ch &lt; UTF8_2_OCTET_MIN_VALUE)</span>
            {
<span class="nc" id="L417">                block.data[limit++] = (byte) ch;</span>
<span class="nc" id="L418">                octets++;</span>
            }
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">            else if (ch &lt; UTF8_3_OCTET_MIN_VALUE)</span>
            {
<span class="nc" id="L422">                block.data[limit++] = (byte) (UTF8_2_OCTET_PREFIX_MASK | (ch &gt;&gt; UTF8_2_OCTET_SHIFT)                    );</span>
<span class="nc" id="L423">                block.data[limit++] = (byte) (UTF8_FOLLOW_PREFIX_MASK  | (ch                        &amp; UTF8_FOLLOW_MASK));</span>
<span class="nc" id="L424">                octets += 2;</span>
            }
            else
            {
<span class="fc" id="L428">                block.data[limit++] = (byte) (UTF8_3_OCTET_PREFIX_MASK | ( ch &gt;&gt; UTF8_3_OCTET_SHIFT)                    );</span>
<span class="fc" id="L429">                block.data[limit++] = (byte) (UTF8_FOLLOW_PREFIX_MASK  | ((ch &gt;&gt; UTF8_2_OCTET_SHIFT) &amp; UTF8_FOLLOW_MASK));</span>
<span class="fc" id="L430">                block.data[limit++] = (byte) (UTF8_FOLLOW_PREFIX_MASK  | ( ch                        &amp; UTF8_FOLLOW_MASK));</span>
<span class="fc" id="L431">                octets += 3;</span>
            }
<span class="fc" id="L433">            off++;</span>
<span class="fc" id="L434">            len--;</span>
<span class="fc" id="L435">        }</span>
<span class="fc" id="L436">        block.limit = limit;</span>

<span class="fc bfc" id="L438" title="All 2 branches covered.">        if (len &gt; 0)</span>
        {
            // just defer to 'slow' writing for non-BMP characters
<span class="nc" id="L441">            return octets + writeUTF8Slow(chars, off, len);</span>
        }
<span class="fc" id="L443">        return octets;</span>
    }

    private int writeUTF8UpTo2Byte(final CharSequence chars, int off, int len)
    {
        // fast path if we fit in the block assuming optimistically for all two-byte
<span class="fc bfc" id="L449" title="All 2 branches covered.">        if ((len * 2) &gt; remaining())</span>
        {
<span class="fc" id="L451">            return writeUTF8Slow(chars, off, len);</span>
        }

<span class="fc" id="L454">        final Block block = current;</span>
<span class="fc" id="L455">        int limit = block.limit;</span>
<span class="fc" id="L456">        char ch = '\0';</span>
<span class="fc" id="L457">        int octets = 0;</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">        while (len &gt; 0)</span>
        {
<span class="fc" id="L460">            ch = chars.charAt(off);</span>
<span class="fc bfc" id="L461" title="All 2 branches covered.">            if (ch &gt;= UTF8_3_OCTET_MIN_VALUE)</span>
            {
                // we lost the 2-byte bet
<span class="fc" id="L464">                break;</span>
            }

<span class="fc bfc" id="L467" title="All 2 branches covered.">            if (ch &lt; UTF8_2_OCTET_MIN_VALUE)</span>
            {
<span class="fc" id="L469">                block.data[limit++] = (byte) ch;</span>
<span class="fc" id="L470">                octets++;</span>
            }
            else
            {
<span class="fc" id="L474">                block.data[limit++] = (byte) (UTF8_2_OCTET_PREFIX_MASK | (ch &gt;&gt; UTF8_2_OCTET_SHIFT)                    );</span>
<span class="fc" id="L475">                block.data[limit++] = (byte) (UTF8_FOLLOW_PREFIX_MASK  | (ch                        &amp; UTF8_FOLLOW_MASK));</span>
<span class="fc" id="L476">                octets += 2;</span>
            }
<span class="fc" id="L478">            off++;</span>
<span class="fc" id="L479">            len--;</span>
        }
<span class="fc" id="L481">        block.limit = limit;</span>

<span class="fc bfc" id="L483" title="All 2 branches covered.">        if (len &gt; 0)</span>
        {
<span class="pc bpc" id="L485" title="3 of 4 branches missed.">            if (ch &gt;= LOW_SURROGATE_FIRST &amp;&amp; ch &lt;= LOW_SURROGATE_LAST)</span>
            {
<span class="nc" id="L487">                throw new IllegalArgumentException(&quot;Unpaired low surrogate: &quot; + ch);</span>
            }
<span class="pc bpc" id="L489" title="1 of 4 branches missed.">            if (ch &gt;= HIGH_SURROGATE_FIRST &amp;&amp; ch &lt;= HIGH_SURROGATE_LAST)</span>
            {
                // just defer to 'slow' writing for non-BMP characters
<span class="nc" id="L492">                return octets + writeUTF8Slow(chars, off, len);</span>
            }

            // we must be a three byte BMP character
<span class="fc" id="L496">            return octets + writeUTF8UpTo3Byte(chars, off, len);</span>
        }
<span class="fc" id="L498">        return octets;</span>
    }

    /** Returns the number of octets written. */
    public int writeUTF8(final CharSequence chars, int off, int len)
    {
        // fast path if we fit in the block assuming optimistically for all ASCII
<span class="fc bfc" id="L505" title="All 2 branches covered.">        if (len &gt; remaining())</span>
        {
<span class="fc" id="L507">            return writeUTF8Slow(chars, off, len);</span>
        }
<span class="fc" id="L509">        final Block block = current;</span>
<span class="fc" id="L510">        int limit = block.limit;</span>
<span class="fc" id="L511">        char ch = '\0';</span>
<span class="fc" id="L512">        int octets = 0;</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">        while (len &gt; 0)</span>
        {
<span class="fc" id="L515">            ch = chars.charAt(off);</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">            if (ch &gt;= UTF8_2_OCTET_MIN_VALUE)</span>
            {
                // we lost the ASCII bet
<span class="fc" id="L519">                break;</span>
            }

<span class="fc" id="L522">            block.data[limit++] = (byte) ch;</span>
<span class="fc" id="L523">            octets++;</span>
<span class="fc" id="L524">            off++;</span>
<span class="fc" id="L525">            len--;</span>
        }
<span class="fc" id="L527">        block.limit = limit;</span>

<span class="fc bfc" id="L529" title="All 2 branches covered.">        if (len &gt; 0)</span>
        {
<span class="fc bfc" id="L531" title="All 2 branches covered.">            if (ch &lt; UTF8_3_OCTET_MIN_VALUE)</span>
            {
<span class="fc" id="L533">                return octets + writeUTF8UpTo2Byte(chars, off, len);</span>
            }
<span class="pc bpc" id="L535" title="1 of 4 branches missed.">            if (ch &gt;= LOW_SURROGATE_FIRST &amp;&amp; ch &lt;= LOW_SURROGATE_LAST)</span>
            {
<span class="fc" id="L537">                throw new IllegalArgumentException(&quot;Unpaired low surrogate: &quot; + ch);</span>
            }
<span class="pc bpc" id="L539" title="1 of 4 branches missed.">            if (ch &gt;= HIGH_SURROGATE_FIRST &amp;&amp; ch &lt;= HIGH_SURROGATE_LAST)</span>
            {
                // just defer to 'slow' writing for non-BMP characters
<span class="fc" id="L542">                return octets + writeUTF8Slow(chars, off, len);</span>
            }

            // we must be a three byte BMP character
<span class="fc" id="L546">            return octets + writeUTF8UpTo3Byte(chars, off, len);</span>
        }
<span class="fc" id="L548">        return octets;</span>
    }

    /** Returns the number of octets written. */
    public int writeUTF8(final CharSequence chars)
    {
<span class="fc" id="L554">        return writeUTF8(chars, 0, chars.length());</span>
    }

    // unsigned fixed integer writes -- does not check sign/bounds

    private static final int UINT_2_OCTET_SHIFT = 8 * 1;
    private static final int UINT_3_OCTET_SHIFT = 8 * 2;
    private static final int UINT_4_OCTET_SHIFT = 8 * 3;
    private static final int UINT_5_OCTET_SHIFT = 8 * 4;
    private static final int UINT_6_OCTET_SHIFT = 8 * 5;
    private static final int UINT_7_OCTET_SHIFT = 8 * 6;
    private static final int UINT_8_OCTET_SHIFT = 8 * 7;


    public void writeUInt8(long value)
    {
<span class="fc" id="L570">        writeByte((byte) value);</span>
<span class="fc" id="L571">    }</span>

    private void writeUInt16Slow(long value)
    {
<span class="fc" id="L575">        writeByte((byte) (value &gt;&gt; UINT_2_OCTET_SHIFT));</span>
<span class="fc" id="L576">        writeByte((byte) (value                      ));</span>
<span class="fc" id="L577">    }</span>

    public void writeUInt16(long value)
    {
<span class="fc bfc" id="L581" title="All 2 branches covered.">        if (remaining() &lt; 2)</span>
        {
<span class="fc" id="L583">            writeUInt16Slow(value);</span>
<span class="fc" id="L584">            return;</span>
        }

<span class="fc" id="L587">        final Block block = current;</span>
<span class="fc" id="L588">        final byte[] data = block.data;</span>
<span class="fc" id="L589">        int limit = block.limit;</span>
<span class="fc" id="L590">        data[limit++] = (byte) (value &gt;&gt; UINT_2_OCTET_SHIFT);</span>
<span class="fc" id="L591">        data[limit++] = (byte) (value                      );</span>
<span class="fc" id="L592">        block.limit = limit;</span>
<span class="fc" id="L593">    }</span>

    private void writeUInt24Slow(long value)
    {
<span class="fc" id="L597">        writeByte((byte) (value &gt;&gt; UINT_3_OCTET_SHIFT));</span>
<span class="fc" id="L598">        writeByte((byte) (value &gt;&gt; UINT_2_OCTET_SHIFT));</span>
<span class="fc" id="L599">        writeByte((byte) (value                      ));</span>
<span class="fc" id="L600">    }</span>

    public void writeUInt24(long value)
    {
<span class="fc bfc" id="L604" title="All 2 branches covered.">        if (remaining() &lt; 3)</span>
        {
<span class="fc" id="L606">            writeUInt24Slow(value);</span>
<span class="fc" id="L607">            return;</span>
        }

<span class="fc" id="L610">        final Block block = current;</span>
<span class="fc" id="L611">        final byte[] data = block.data;</span>
<span class="fc" id="L612">        int limit = block.limit;</span>
<span class="fc" id="L613">        data[limit++] = (byte) (value &gt;&gt; UINT_3_OCTET_SHIFT);</span>
<span class="fc" id="L614">        data[limit++] = (byte) (value &gt;&gt; UINT_2_OCTET_SHIFT);</span>
<span class="fc" id="L615">        data[limit++] = (byte) (value                      );</span>
<span class="fc" id="L616">        block.limit = limit;</span>
<span class="fc" id="L617">    }</span>

    private void writeUInt32Slow(long value)
    {
<span class="fc" id="L621">        writeByte((byte) (value &gt;&gt; UINT_4_OCTET_SHIFT));</span>
<span class="fc" id="L622">        writeByte((byte) (value &gt;&gt; UINT_3_OCTET_SHIFT));</span>
<span class="fc" id="L623">        writeByte((byte) (value &gt;&gt; UINT_2_OCTET_SHIFT));</span>
<span class="fc" id="L624">        writeByte((byte) (value                      ));</span>
<span class="fc" id="L625">    }</span>

    public void writeUInt32(long value)
    {
<span class="fc bfc" id="L629" title="All 2 branches covered.">        if (remaining() &lt; 4)</span>
        {
<span class="fc" id="L631">            writeUInt32Slow(value);</span>
<span class="fc" id="L632">            return;</span>
        }

<span class="fc" id="L635">        final Block block = current;</span>
<span class="fc" id="L636">        final byte[] data = block.data;</span>
<span class="fc" id="L637">        int limit = block.limit;</span>
<span class="fc" id="L638">        data[limit++] = (byte) (value &gt;&gt; UINT_4_OCTET_SHIFT);</span>
<span class="fc" id="L639">        data[limit++] = (byte) (value &gt;&gt; UINT_3_OCTET_SHIFT);</span>
<span class="fc" id="L640">        data[limit++] = (byte) (value &gt;&gt; UINT_2_OCTET_SHIFT);</span>
<span class="fc" id="L641">        data[limit++] = (byte) (value                      );</span>
<span class="fc" id="L642">        block.limit = limit;</span>
<span class="fc" id="L643">    }</span>

    private void writeUInt40Slow(long value)
    {
<span class="fc" id="L647">        writeByte((byte) (value &gt;&gt; UINT_5_OCTET_SHIFT));</span>
<span class="fc" id="L648">        writeByte((byte) (value &gt;&gt; UINT_4_OCTET_SHIFT));</span>
<span class="fc" id="L649">        writeByte((byte) (value &gt;&gt; UINT_3_OCTET_SHIFT));</span>
<span class="fc" id="L650">        writeByte((byte) (value &gt;&gt; UINT_2_OCTET_SHIFT));</span>
<span class="fc" id="L651">        writeByte((byte) (value                      ));</span>
<span class="fc" id="L652">    }</span>

    public void writeUInt40(long value)
    {
<span class="fc bfc" id="L656" title="All 2 branches covered.">        if (remaining() &lt; 5)</span>
        {
<span class="fc" id="L658">            writeUInt40Slow(value);</span>
<span class="fc" id="L659">            return;</span>
        }

<span class="fc" id="L662">        final Block block = current;</span>
<span class="fc" id="L663">        final byte[] data = block.data;</span>
<span class="fc" id="L664">        int limit = block.limit;</span>
<span class="fc" id="L665">        data[limit++] = (byte) (value &gt;&gt; UINT_5_OCTET_SHIFT);</span>
<span class="fc" id="L666">        data[limit++] = (byte) (value &gt;&gt; UINT_4_OCTET_SHIFT);</span>
<span class="fc" id="L667">        data[limit++] = (byte) (value &gt;&gt; UINT_3_OCTET_SHIFT);</span>
<span class="fc" id="L668">        data[limit++] = (byte) (value &gt;&gt; UINT_2_OCTET_SHIFT);</span>
<span class="fc" id="L669">        data[limit++] = (byte) (value                      );</span>
<span class="fc" id="L670">        block.limit = limit;</span>
<span class="fc" id="L671">    }</span>

    private void writeUInt48Slow(long value)
    {
<span class="fc" id="L675">        writeByte((byte) (value &gt;&gt; UINT_6_OCTET_SHIFT));</span>
<span class="fc" id="L676">        writeByte((byte) (value &gt;&gt; UINT_5_OCTET_SHIFT));</span>
<span class="fc" id="L677">        writeByte((byte) (value &gt;&gt; UINT_4_OCTET_SHIFT));</span>
<span class="fc" id="L678">        writeByte((byte) (value &gt;&gt; UINT_3_OCTET_SHIFT));</span>
<span class="fc" id="L679">        writeByte((byte) (value &gt;&gt; UINT_2_OCTET_SHIFT));</span>
<span class="fc" id="L680">        writeByte((byte) (value                      ));</span>
<span class="fc" id="L681">    }</span>

    public void writeUInt48(long value)
    {
<span class="fc bfc" id="L685" title="All 2 branches covered.">        if (remaining() &lt; 6)</span>
        {
<span class="fc" id="L687">            writeUInt48Slow(value);</span>
<span class="fc" id="L688">            return;</span>
        }

<span class="fc" id="L691">        final Block block = current;</span>
<span class="fc" id="L692">        final byte[] data = block.data;</span>
<span class="fc" id="L693">        int limit = block.limit;</span>
<span class="fc" id="L694">        data[limit++] = (byte) (value &gt;&gt; UINT_6_OCTET_SHIFT);</span>
<span class="fc" id="L695">        data[limit++] = (byte) (value &gt;&gt; UINT_5_OCTET_SHIFT);</span>
<span class="fc" id="L696">        data[limit++] = (byte) (value &gt;&gt; UINT_4_OCTET_SHIFT);</span>
<span class="fc" id="L697">        data[limit++] = (byte) (value &gt;&gt; UINT_3_OCTET_SHIFT);</span>
<span class="fc" id="L698">        data[limit++] = (byte) (value &gt;&gt; UINT_2_OCTET_SHIFT);</span>
<span class="fc" id="L699">        data[limit++] = (byte) ( value                     );</span>
<span class="fc" id="L700">        block.limit = limit;</span>
<span class="fc" id="L701">    }</span>

    private void writeUInt56Slow(long value)
    {
<span class="fc" id="L705">        writeByte((byte) (value &gt;&gt; UINT_7_OCTET_SHIFT));</span>
<span class="fc" id="L706">        writeByte((byte) (value &gt;&gt; UINT_6_OCTET_SHIFT));</span>
<span class="fc" id="L707">        writeByte((byte) (value &gt;&gt; UINT_5_OCTET_SHIFT));</span>
<span class="fc" id="L708">        writeByte((byte) (value &gt;&gt; UINT_4_OCTET_SHIFT));</span>
<span class="fc" id="L709">        writeByte((byte) (value &gt;&gt; UINT_3_OCTET_SHIFT));</span>
<span class="fc" id="L710">        writeByte((byte) (value &gt;&gt; UINT_2_OCTET_SHIFT));</span>
<span class="fc" id="L711">        writeByte((byte) (value                      ));</span>
<span class="fc" id="L712">    }</span>

    public void writeUInt56(long value)
    {
<span class="fc bfc" id="L716" title="All 2 branches covered.">        if (remaining() &lt; 7)</span>
        {
<span class="fc" id="L718">            writeUInt56Slow(value);</span>
<span class="fc" id="L719">            return;</span>
        }

<span class="fc" id="L722">        final Block block = current;</span>
<span class="fc" id="L723">        final byte[] data = block.data;</span>
<span class="fc" id="L724">        int limit = block.limit;</span>
<span class="fc" id="L725">        data[limit++] = (byte) (value &gt;&gt; UINT_7_OCTET_SHIFT);</span>
<span class="fc" id="L726">        data[limit++] = (byte) (value &gt;&gt; UINT_6_OCTET_SHIFT);</span>
<span class="fc" id="L727">        data[limit++] = (byte) (value &gt;&gt; UINT_5_OCTET_SHIFT);</span>
<span class="fc" id="L728">        data[limit++] = (byte) (value &gt;&gt; UINT_4_OCTET_SHIFT);</span>
<span class="fc" id="L729">        data[limit++] = (byte) (value &gt;&gt; UINT_3_OCTET_SHIFT);</span>
<span class="fc" id="L730">        data[limit++] = (byte) (value &gt;&gt; UINT_2_OCTET_SHIFT);</span>
<span class="fc" id="L731">        data[limit++] = (byte) (value                      );</span>
<span class="fc" id="L732">        block.limit = limit;</span>
<span class="fc" id="L733">    }</span>

    private void writeUInt64Slow(long value)
    {
<span class="fc" id="L737">        writeByte((byte) (value &gt;&gt; UINT_8_OCTET_SHIFT));</span>
<span class="fc" id="L738">        writeByte((byte) (value &gt;&gt; UINT_7_OCTET_SHIFT));</span>
<span class="fc" id="L739">        writeByte((byte) (value &gt;&gt; UINT_6_OCTET_SHIFT));</span>
<span class="fc" id="L740">        writeByte((byte) (value &gt;&gt; UINT_5_OCTET_SHIFT));</span>
<span class="fc" id="L741">        writeByte((byte) (value &gt;&gt; UINT_4_OCTET_SHIFT));</span>
<span class="fc" id="L742">        writeByte((byte) (value &gt;&gt; UINT_3_OCTET_SHIFT));</span>
<span class="fc" id="L743">        writeByte((byte) (value &gt;&gt; UINT_2_OCTET_SHIFT));</span>
<span class="fc" id="L744">        writeByte((byte) ( value                     ));</span>
<span class="fc" id="L745">    }</span>

    public void writeUInt64(long value)
    {
<span class="fc bfc" id="L749" title="All 2 branches covered.">        if (remaining() &lt; 8)</span>
        {
<span class="fc" id="L751">            writeUInt64Slow(value);</span>
<span class="fc" id="L752">            return;</span>
        }

<span class="fc" id="L755">        final Block block = current;</span>
<span class="fc" id="L756">        final byte[] data = block.data;</span>
<span class="fc" id="L757">        int limit = block.limit;</span>
<span class="fc" id="L758">        data[limit++] = (byte) (value &gt;&gt; UINT_8_OCTET_SHIFT);</span>
<span class="fc" id="L759">        data[limit++] = (byte) (value &gt;&gt; UINT_7_OCTET_SHIFT);</span>
<span class="fc" id="L760">        data[limit++] = (byte) (value &gt;&gt; UINT_6_OCTET_SHIFT);</span>
<span class="fc" id="L761">        data[limit++] = (byte) (value &gt;&gt; UINT_5_OCTET_SHIFT);</span>
<span class="fc" id="L762">        data[limit++] = (byte) (value &gt;&gt; UINT_4_OCTET_SHIFT);</span>
<span class="fc" id="L763">        data[limit++] = (byte) (value &gt;&gt; UINT_3_OCTET_SHIFT);</span>
<span class="fc" id="L764">        data[limit++] = (byte) (value &gt;&gt; UINT_2_OCTET_SHIFT);</span>
<span class="fc" id="L765">        data[limit++] = (byte) ( value                      );</span>
<span class="fc" id="L766">        block.limit = limit;</span>


<span class="fc" id="L769">    }</span>

    // signed fixed integer writes - does not check bounds (especially important for IntX.MIN_VALUE).

    private static final long INT8_SIGN_MASK  = 1L &lt;&lt; ((8 * 1) - 1);
    private static final long INT16_SIGN_MASK = 1L &lt;&lt; ((8 * 2) - 1);
    private static final long INT24_SIGN_MASK = 1L &lt;&lt; ((8 * 3) - 1);
    private static final long INT32_SIGN_MASK = 1L &lt;&lt; ((8 * 4) - 1);
    private static final long INT40_SIGN_MASK = 1L &lt;&lt; ((8 * 5) - 1);
    private static final long INT48_SIGN_MASK = 1L &lt;&lt; ((8 * 6) - 1);
    private static final long INT56_SIGN_MASK = 1L &lt;&lt; ((8 * 7) - 1);
    private static final long INT64_SIGN_MASK = 1L &lt;&lt; ((8 * 8) - 1);

    public void writeInt8(long value)
    {
<span class="fc bfc" id="L784" title="All 2 branches covered.">        if (value &lt; 0)</span>
        {
<span class="fc" id="L786">            value = (-value) | INT8_SIGN_MASK;</span>
        }
<span class="fc" id="L788">        writeUInt8(value);</span>
<span class="fc" id="L789">    }</span>


    public void writeInt16(long value)
    {
<span class="fc bfc" id="L794" title="All 2 branches covered.">        if (value &lt; 0)</span>
        {
<span class="fc" id="L796">            value = (-value) | INT16_SIGN_MASK;</span>
        }
<span class="fc" id="L798">        writeUInt16(value);</span>
<span class="fc" id="L799">    }</span>

    public void writeInt24(long value)
    {
<span class="fc bfc" id="L803" title="All 2 branches covered.">        if (value &lt; 0)</span>
        {
<span class="fc" id="L805">            value = (-value) | INT24_SIGN_MASK;</span>
        }
<span class="fc" id="L807">        writeUInt24(value);</span>
<span class="fc" id="L808">    }</span>


    public void writeInt32(long value)
    {
<span class="fc bfc" id="L813" title="All 2 branches covered.">        if (value &lt; 0)</span>
        {
<span class="fc" id="L815">            value = (-value) | INT32_SIGN_MASK;</span>
        }
<span class="fc" id="L817">        writeUInt32(value);</span>
<span class="fc" id="L818">    }</span>


    public void writeInt40(long value)
    {
<span class="fc bfc" id="L823" title="All 2 branches covered.">        if (value &lt; 0)</span>
        {
<span class="fc" id="L825">            value = (-value) | INT40_SIGN_MASK;</span>
        }
<span class="fc" id="L827">        writeUInt40(value);</span>
<span class="fc" id="L828">    }</span>


    public void writeInt48(long value)
    {
<span class="fc bfc" id="L833" title="All 2 branches covered.">        if (value &lt; 0)</span>
        {
<span class="fc" id="L835">            value = (-value) | INT48_SIGN_MASK;</span>
        }
<span class="fc" id="L837">        writeUInt48(value);</span>
<span class="fc" id="L838">    }</span>


    public void writeInt56(long value)
    {
<span class="fc bfc" id="L843" title="All 2 branches covered.">        if (value &lt; 0)</span>
        {
<span class="fc" id="L845">            value = (-value) | INT56_SIGN_MASK;</span>
        }
<span class="fc" id="L847">        writeUInt56(value);</span>
<span class="fc" id="L848">    }</span>


    public void writeInt64(long value)
    {
<span class="fc bfc" id="L853" title="All 2 branches covered.">        if (value &lt; 0)</span>
        {
<span class="fc" id="L855">            value = (-value) | INT64_SIGN_MASK;</span>
        }
<span class="fc" id="L857">        writeUInt64(value);</span>
<span class="fc" id="L858">    }</span>

    // variable length integer writing

    private static final long VAR_INT_BITS_PER_OCTET = 7;
    private static final long VAR_INT_MASK = 0x7F;

    private static final long VAR_UINT_9_OCTET_SHIFT = (8 * VAR_INT_BITS_PER_OCTET);
    private static final long VAR_UINT_9_OCTET_MIN_VALUE = (1L &lt;&lt; VAR_UINT_9_OCTET_SHIFT);

    private static final long VAR_UINT_8_OCTET_SHIFT = (7 * VAR_INT_BITS_PER_OCTET);
    private static final long VAR_UINT_8_OCTET_MIN_VALUE = (1L &lt;&lt; VAR_UINT_8_OCTET_SHIFT);

    private static final long VAR_UINT_7_OCTET_SHIFT = (6 * VAR_INT_BITS_PER_OCTET);
    private static final long VAR_UINT_7_OCTET_MIN_VALUE = (1L &lt;&lt; VAR_UINT_7_OCTET_SHIFT);

    private static final long VAR_UINT_6_OCTET_SHIFT = (5 * VAR_INT_BITS_PER_OCTET);
    private static final long VAR_UINT_6_OCTET_MIN_VALUE = (1L &lt;&lt; VAR_UINT_6_OCTET_SHIFT);

    private static final long VAR_UINT_5_OCTET_SHIFT = (4 * VAR_INT_BITS_PER_OCTET);
    private static final long VAR_UINT_5_OCTET_MIN_VALUE = (1L &lt;&lt; VAR_UINT_5_OCTET_SHIFT);

    private static final long VAR_UINT_4_OCTET_SHIFT = (3 * VAR_INT_BITS_PER_OCTET);
    private static final long VAR_UINT_4_OCTET_MIN_VALUE = (1L &lt;&lt; VAR_UINT_4_OCTET_SHIFT);

    private static final long VAR_UINT_3_OCTET_SHIFT = (2 * VAR_INT_BITS_PER_OCTET);
    private static final long VAR_UINT_3_OCTET_MIN_VALUE = (1L &lt;&lt; VAR_UINT_3_OCTET_SHIFT);

    private static final long VAR_UINT_2_OCTET_SHIFT = (1 * VAR_INT_BITS_PER_OCTET);
    private static final long VAR_UINT_2_OCTET_MIN_VALUE = (1L &lt;&lt; VAR_UINT_2_OCTET_SHIFT);

    private static final long VAR_INT_FINAL_OCTET_SIGNAL_MASK = 0x80;

    private int writeVarUIntSlow(final long value)
    {
<span class="fc" id="L893">        int size = 1;</span>
<span class="fc bfc" id="L894" title="All 2 branches covered.">        if (value &gt;= VAR_UINT_9_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L896">            writeUInt8((value &gt;&gt; VAR_UINT_9_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L897">            size++;</span>
        }
<span class="fc bfc" id="L899" title="All 2 branches covered.">        if (value &gt;= VAR_UINT_8_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L901">            writeUInt8((value &gt;&gt; VAR_UINT_8_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L902">            size++;</span>
        }
<span class="fc bfc" id="L904" title="All 2 branches covered.">        if (value &gt;= VAR_UINT_7_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L906">            writeUInt8((value &gt;&gt; VAR_UINT_7_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L907">            size++;</span>
        }
<span class="fc bfc" id="L909" title="All 2 branches covered.">        if (value &gt;= VAR_UINT_6_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L911">            writeUInt8((value &gt;&gt; VAR_UINT_6_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L912">            size++;</span>
        }
<span class="fc bfc" id="L914" title="All 2 branches covered.">        if (value &gt;= VAR_UINT_5_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L916">            writeUInt8((value &gt;&gt; VAR_UINT_5_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L917">            size++;</span>
        }
<span class="fc bfc" id="L919" title="All 2 branches covered.">        if (value &gt;= VAR_UINT_4_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L921">            writeUInt8((value &gt;&gt; VAR_UINT_4_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L922">            size++;</span>
        }
<span class="fc bfc" id="L924" title="All 2 branches covered.">        if (value &gt;= VAR_UINT_3_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L926">            writeUInt8((value &gt;&gt; VAR_UINT_3_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L927">            size++;</span>
        }
<span class="pc bpc" id="L929" title="1 of 2 branches missed.">        if (value &gt;= VAR_UINT_2_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L931">            writeUInt8((value &gt;&gt; VAR_UINT_2_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L932">            size++;</span>
        }
<span class="fc" id="L934">        writeUInt8((value &amp; VAR_INT_MASK) | VAR_INT_FINAL_OCTET_SIGNAL_MASK);</span>
<span class="fc" id="L935">        return size;</span>
    }

    private int writeVarUIntDirect2(final long value)
    {
<span class="fc" id="L940">        final Block block = current;</span>
<span class="fc" id="L941">        final byte[] data = block.data;</span>
<span class="fc" id="L942">        int limit = block.limit;</span>
<span class="fc" id="L943">        data[limit++] = (byte)  ((value &gt;&gt; VAR_UINT_2_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L944">        data[limit++] = (byte) (((value)                           &amp; VAR_INT_MASK) | VAR_INT_FINAL_OCTET_SIGNAL_MASK);</span>

<span class="fc" id="L946">        block.limit = limit;</span>
<span class="fc" id="L947">        return 2;</span>
    }

    private int writeVarUIntDirect3(final long value)
    {
<span class="fc" id="L952">        final Block block = current;</span>
<span class="fc" id="L953">        final byte[] data = block.data;</span>
<span class="fc" id="L954">        int limit = block.limit;</span>
<span class="fc" id="L955">        data[limit++] = (byte)  ((value &gt;&gt; VAR_UINT_3_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L956">        data[limit++] = (byte)  ((value &gt;&gt; VAR_UINT_2_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L957">        data[limit++] = (byte) (((value)                           &amp; VAR_INT_MASK) | VAR_INT_FINAL_OCTET_SIGNAL_MASK);</span>

<span class="fc" id="L959">        block.limit = limit;</span>
<span class="fc" id="L960">        return 3;</span>
    }

    private int writeVarUIntDirect4(final long value)
    {
<span class="fc" id="L965">        final Block block = current;</span>
<span class="fc" id="L966">        final byte[] data = block.data;</span>
<span class="fc" id="L967">        int limit = block.limit;</span>
<span class="fc" id="L968">        data[limit++] = (byte)  ((value &gt;&gt; VAR_UINT_4_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L969">        data[limit++] = (byte)  ((value &gt;&gt; VAR_UINT_3_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L970">        data[limit++] = (byte)  ((value &gt;&gt; VAR_UINT_2_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L971">        data[limit++] = (byte) (((value)                           &amp; VAR_INT_MASK) | VAR_INT_FINAL_OCTET_SIGNAL_MASK);</span>

<span class="fc" id="L973">        block.limit = limit;</span>
<span class="fc" id="L974">        return 4;</span>
    }

    private int writeVarUIntDirect5(final long value)
    {
<span class="fc" id="L979">        final Block block = current;</span>
<span class="fc" id="L980">        final byte[] data = block.data;</span>
<span class="fc" id="L981">        int limit = block.limit;</span>
<span class="fc" id="L982">        data[limit++] = (byte)  ((value &gt;&gt; VAR_UINT_5_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L983">        data[limit++] = (byte)  ((value &gt;&gt; VAR_UINT_4_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L984">        data[limit++] = (byte)  ((value &gt;&gt; VAR_UINT_3_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L985">        data[limit++] = (byte)  ((value &gt;&gt; VAR_UINT_2_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L986">        data[limit++] = (byte) (((value)                           &amp; VAR_INT_MASK) | VAR_INT_FINAL_OCTET_SIGNAL_MASK);</span>

<span class="fc" id="L988">        block.limit = limit;</span>
<span class="fc" id="L989">        return 5;</span>
    }

    public int writeVarUInt(final long value)
    {
<span class="fc bfc" id="L994" title="All 2 branches covered.">        if (value &lt; VAR_UINT_2_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L996">            writeUInt8((value &amp; 0x7F) | 0x80);</span>
<span class="fc" id="L997">            return 1;</span>
        }
<span class="fc bfc" id="L999" title="All 2 branches covered.">        if (value &lt; VAR_UINT_3_OCTET_MIN_VALUE)</span>
        {
<span class="fc bfc" id="L1001" title="All 2 branches covered.">            if (remaining() &lt; 2)</span>
            {
<span class="fc" id="L1003">                return writeVarUIntSlow(value);</span>
            }
<span class="fc" id="L1005">            return writeVarUIntDirect2(value);</span>
        }
<span class="fc bfc" id="L1007" title="All 2 branches covered.">        if (value &lt; VAR_UINT_4_OCTET_MIN_VALUE)</span>
        {
<span class="fc bfc" id="L1009" title="All 2 branches covered.">            if (remaining() &lt; 3)</span>
            {
<span class="fc" id="L1011">                return writeVarUIntSlow(value);</span>
            }
<span class="fc" id="L1013">            return writeVarUIntDirect3(value);</span>
        }
<span class="fc bfc" id="L1015" title="All 2 branches covered.">        if (value &lt; VAR_UINT_5_OCTET_MIN_VALUE)</span>
        {
<span class="fc bfc" id="L1017" title="All 2 branches covered.">            if (remaining() &lt; 4)</span>
            {
<span class="fc" id="L1019">                return writeVarUIntSlow(value);</span>
            }
<span class="fc" id="L1021">            return writeVarUIntDirect4(value);</span>
        }
<span class="fc bfc" id="L1023" title="All 2 branches covered.">        if (value &lt; VAR_UINT_6_OCTET_MIN_VALUE)</span>
        {
<span class="fc bfc" id="L1025" title="All 2 branches covered.">            if (remaining() &lt; 5)</span>
            {
<span class="fc" id="L1027">                return writeVarUIntSlow(value);</span>
            }
<span class="fc" id="L1029">            return writeVarUIntDirect5(value);</span>

        }
        // TODO determine if it is worth doing the fast path beyond 2**35 - 1

        // we give up--go to the 'slow' path
<span class="fc" id="L1035">        return writeVarUIntSlow(value);</span>
    }

    private static final long VAR_INT_SIGNED_OCTET_MASK = 0x3F;
    private static final long VAR_INT_SIGNBIT_ON_MASK   = 0x40L;
    private static final long VAR_INT_SIGNBIT_OFF_MASK  = 0x00L;

    // note that the highest order bit for signed 64-bit values cannot fit in 9 bytes with the sign
    private static final long VAR_INT_10_OCTET_SHIFT = 62;

    private static final long VAR_INT_10_OCTET_MIN_VALUE = (1L &lt;&lt; VAR_INT_10_OCTET_SHIFT);
    private static final long VAR_INT_9_OCTET_MIN_VALUE  = (VAR_UINT_9_OCTET_MIN_VALUE &gt;&gt; 1);
    private static final long VAR_INT_8_OCTET_MIN_VALUE  = (VAR_UINT_8_OCTET_MIN_VALUE &gt;&gt; 1);
    private static final long VAR_INT_7_OCTET_MIN_VALUE  = (VAR_UINT_7_OCTET_MIN_VALUE &gt;&gt; 1);
    private static final long VAR_INT_6_OCTET_MIN_VALUE  = (VAR_UINT_6_OCTET_MIN_VALUE &gt;&gt; 1);
    private static final long VAR_INT_5_OCTET_MIN_VALUE  = (VAR_UINT_5_OCTET_MIN_VALUE &gt;&gt; 1);
    private static final long VAR_INT_4_OCTET_MIN_VALUE  = (VAR_UINT_4_OCTET_MIN_VALUE &gt;&gt; 1);
    private static final long VAR_INT_3_OCTET_MIN_VALUE  = (VAR_UINT_3_OCTET_MIN_VALUE &gt;&gt; 1);
    private static final long VAR_INT_2_OCTET_MIN_VALUE  = (VAR_UINT_2_OCTET_MIN_VALUE &gt;&gt; 1);

    private int writeVarIntSlow(final long magnitude, final long signMask)
    {
<span class="fc" id="L1057">        int size = 1;</span>
<span class="fc bfc" id="L1058" title="All 2 branches covered.">        if (magnitude &gt;= VAR_INT_10_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L1060">            writeUInt8(((magnitude &gt;&gt; VAR_INT_10_OCTET_SHIFT) &amp; VAR_INT_SIGNED_OCTET_MASK) | signMask);</span>
<span class="fc" id="L1061">            size++;</span>
        }
<span class="fc bfc" id="L1063" title="All 2 branches covered.">        if (magnitude &gt;= VAR_INT_9_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L1065">            final long bits = (magnitude &gt;&gt; VAR_UINT_9_OCTET_SHIFT);</span>
<span class="fc bfc" id="L1066" title="All 2 branches covered.">            writeUInt8(size == 1 ? ((bits &amp; VAR_INT_SIGNED_OCTET_MASK) | signMask) : (bits &amp; VAR_INT_MASK));</span>
<span class="fc" id="L1067">            size++;</span>
        }
<span class="fc bfc" id="L1069" title="All 2 branches covered.">        if (magnitude &gt;= VAR_INT_8_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L1071">            final long bits = (magnitude &gt;&gt; VAR_UINT_8_OCTET_SHIFT);</span>
<span class="fc bfc" id="L1072" title="All 2 branches covered.">            writeUInt8(size == 1 ? ((bits &amp; VAR_INT_SIGNED_OCTET_MASK) | signMask) : (bits &amp; VAR_INT_MASK));</span>
<span class="fc" id="L1073">            size++;</span>
        }
<span class="fc bfc" id="L1075" title="All 2 branches covered.">        if (magnitude &gt;= VAR_INT_7_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L1077">            final long bits = (magnitude &gt;&gt; VAR_UINT_7_OCTET_SHIFT);</span>
<span class="fc bfc" id="L1078" title="All 2 branches covered.">            writeUInt8(size == 1 ? ((bits &amp; VAR_INT_SIGNED_OCTET_MASK) | signMask) : (bits &amp; VAR_INT_MASK));</span>
<span class="fc" id="L1079">            size++;</span>
        }
<span class="fc bfc" id="L1081" title="All 2 branches covered.">        if (magnitude &gt;= VAR_INT_6_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L1083">            final long bits = (magnitude &gt;&gt; VAR_UINT_6_OCTET_SHIFT);</span>
<span class="fc bfc" id="L1084" title="All 2 branches covered.">            writeUInt8(size == 1 ? ((bits &amp; VAR_INT_SIGNED_OCTET_MASK) | signMask) : (bits &amp; VAR_INT_MASK));</span>
<span class="fc" id="L1085">            size++;</span>
        }
<span class="fc bfc" id="L1087" title="All 2 branches covered.">        if (magnitude &gt;= VAR_INT_5_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L1089">            final long bits = (magnitude &gt;&gt; VAR_UINT_5_OCTET_SHIFT);</span>
<span class="fc bfc" id="L1090" title="All 2 branches covered.">            writeUInt8(size == 1 ? ((bits &amp; VAR_INT_SIGNED_OCTET_MASK) | signMask) : (bits &amp; VAR_INT_MASK));</span>
<span class="fc" id="L1091">            size++;</span>
        }
<span class="fc bfc" id="L1093" title="All 2 branches covered.">        if (magnitude &gt;= VAR_INT_4_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L1095">            final long bits = (magnitude &gt;&gt; VAR_UINT_4_OCTET_SHIFT);</span>
<span class="fc bfc" id="L1096" title="All 2 branches covered.">            writeUInt8(size == 1 ? ((bits &amp; VAR_INT_SIGNED_OCTET_MASK) | signMask) : (bits &amp; VAR_INT_MASK));</span>
<span class="fc" id="L1097">            size++;</span>
        }
<span class="fc bfc" id="L1099" title="All 2 branches covered.">        if (magnitude &gt;= VAR_INT_3_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L1101">            final long bits = (magnitude &gt;&gt; VAR_UINT_3_OCTET_SHIFT);</span>
<span class="fc bfc" id="L1102" title="All 2 branches covered.">            writeUInt8(size == 1 ? ((bits &amp; VAR_INT_SIGNED_OCTET_MASK) | signMask) : (bits &amp; VAR_INT_MASK));</span>
<span class="fc" id="L1103">            size++;</span>
        }
<span class="pc bpc" id="L1105" title="1 of 2 branches missed.">        if (magnitude &gt;= VAR_INT_2_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L1107">            final long bits = (magnitude &gt;&gt; VAR_UINT_2_OCTET_SHIFT);</span>
<span class="fc bfc" id="L1108" title="All 2 branches covered.">            writeUInt8(size == 1 ? ((bits &amp; VAR_INT_SIGNED_OCTET_MASK) | signMask) : (bits &amp; VAR_INT_MASK));</span>
<span class="fc" id="L1109">            size++;</span>
        }
<span class="pc bpc" id="L1111" title="1 of 2 branches missed.">        writeUInt8((size == 1 ? ((magnitude &amp; VAR_INT_SIGNED_OCTET_MASK) | signMask) : (magnitude &amp; VAR_INT_MASK)) | VAR_INT_FINAL_OCTET_SIGNAL_MASK);</span>

<span class="fc" id="L1113">        return size;</span>
    }

    private static final long VAR_INT_BITS_PER_SIGNED_OCTET = 6;
    private static final long VAR_SINT_2_OCTET_SHIFT = VAR_INT_BITS_PER_SIGNED_OCTET + (1 * VAR_INT_BITS_PER_OCTET);
    private static final long VAR_SINT_3_OCTET_SHIFT = VAR_INT_BITS_PER_SIGNED_OCTET + (2 * VAR_INT_BITS_PER_OCTET);
    private static final long VAR_SINT_4_OCTET_SHIFT = VAR_INT_BITS_PER_SIGNED_OCTET + (3 * VAR_INT_BITS_PER_OCTET);
    private static final long VAR_SINT_5_OCTET_SHIFT = VAR_INT_BITS_PER_SIGNED_OCTET + (4 * VAR_INT_BITS_PER_OCTET);

    public int writeVarInt(long value)
    {
<span class="pc bpc" id="L1124" title="2 of 4 branches missed.">        assert value != Long.MIN_VALUE;</span>

<span class="fc bfc" id="L1126" title="All 2 branches covered.">        final long signMask = value &lt; 0 ? VAR_INT_SIGNBIT_ON_MASK : VAR_INT_SIGNBIT_OFF_MASK;</span>
<span class="fc bfc" id="L1127" title="All 2 branches covered.">        final long magnitude = value &lt; 0 ? -value : value;</span>
<span class="fc bfc" id="L1128" title="All 2 branches covered.">        if (magnitude &lt; VAR_INT_2_OCTET_MIN_VALUE)</span>
        {
<span class="fc" id="L1130">            writeUInt8((magnitude &amp; VAR_INT_SIGNED_OCTET_MASK) | VAR_INT_FINAL_OCTET_SIGNAL_MASK | signMask);</span>
<span class="fc" id="L1131">            return 1;</span>
        }
<span class="fc bfc" id="L1133" title="All 2 branches covered.">        final long signBit = value &lt; 0 ? 1 : 0;</span>
<span class="fc" id="L1134">        final int remaining = remaining();</span>
<span class="fc bfc" id="L1135" title="All 4 branches covered.">        if (magnitude &lt; VAR_INT_3_OCTET_MIN_VALUE &amp;&amp; remaining &gt;= 2)</span>
        {
<span class="fc" id="L1137">            return writeVarUIntDirect2(magnitude | (signBit &lt;&lt; VAR_SINT_2_OCTET_SHIFT));</span>
        }
<span class="fc bfc" id="L1139" title="All 4 branches covered.">        else if (magnitude &lt; VAR_INT_4_OCTET_MIN_VALUE &amp;&amp; remaining &gt;= 3)</span>
        {
<span class="fc" id="L1141">            return writeVarUIntDirect3(magnitude | (signBit &lt;&lt; VAR_SINT_3_OCTET_SHIFT));</span>
        }
<span class="fc bfc" id="L1143" title="All 4 branches covered.">        else if (magnitude &lt; VAR_INT_5_OCTET_MIN_VALUE &amp;&amp; remaining &gt;= 4)</span>
        {
<span class="fc" id="L1145">            return writeVarUIntDirect4(magnitude | (signBit &lt;&lt; VAR_SINT_4_OCTET_SHIFT));</span>
        }
<span class="fc bfc" id="L1147" title="All 4 branches covered.">        else if (magnitude &lt; VAR_INT_6_OCTET_MIN_VALUE &amp;&amp; remaining &gt;= 5)</span>
        {
<span class="fc" id="L1149">            return writeVarUIntDirect5(magnitude | (signBit &lt;&lt; VAR_SINT_5_OCTET_SHIFT));</span>
        }
        // TODO determine if it is worth doing the fast path beyond 2**34 - 1

        // we give up--go to the slow path
<span class="fc" id="L1154">        return writeVarIntSlow(magnitude, signMask);</span>
    }

    // write variable integer of specific size at a specified position -- no bounds checking, will not expand the buffer

    public void writeVarUIntDirect1At(final long position, final long value)
    {
<span class="fc" id="L1161">        writeUInt8At(position, (value &amp; VAR_INT_MASK) | VAR_INT_FINAL_OCTET_SIGNAL_MASK);</span>
<span class="fc" id="L1162">    }</span>

    private void writeVarUIntDirect2StraddlingAt(final int index, final int offset, final long value)
    {
        // XXX we're stradling a block
<span class="fc" id="L1167">        final Block block1 = blocks.get(index);</span>
<span class="fc" id="L1168">        block1.data[offset] = (byte) ((value &gt;&gt; VAR_UINT_2_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L1169">        final Block block2 = blocks.get(index + 1);</span>
<span class="fc" id="L1170">        block2.data[0]      = (byte) ((value                            &amp; VAR_INT_MASK) | VAR_INT_FINAL_OCTET_SIGNAL_MASK);</span>
<span class="fc" id="L1171">    }</span>

    public void writeVarUIntDirect2At(long position, long value)
    {
<span class="fc" id="L1175">        final int index = index(position);</span>
<span class="fc" id="L1176">        final int offset = offset(position);</span>

<span class="fc bfc" id="L1178" title="All 2 branches covered.">        if (offset + 2 &gt; allocator.getBlockSize())</span>
        {
<span class="fc" id="L1180">            writeVarUIntDirect2StraddlingAt(index, offset, value);</span>
<span class="fc" id="L1181">            return;</span>
        }

<span class="fc" id="L1184">        final Block block = blocks.get(index);</span>
<span class="fc" id="L1185">        block.data[offset    ] = (byte) ((value &gt;&gt; VAR_UINT_2_OCTET_SHIFT) &amp; VAR_INT_MASK);</span>
<span class="fc" id="L1186">        block.data[offset + 1] = (byte) ((value                            &amp; VAR_INT_MASK) | VAR_INT_FINAL_OCTET_SIGNAL_MASK);</span>
<span class="fc" id="L1187">    }</span>

    public void writeUInt8At(final long position, final long value)
    {
<span class="fc" id="L1191">        final int index = index(position);</span>
<span class="fc" id="L1192">        final int offset = offset(position);</span>

        // XXX we'll never overrun a block unless we're given a position past our block array
<span class="fc" id="L1195">        final Block block = blocks.get(index);</span>
<span class="fc" id="L1196">        block.data[offset] = (byte) value;</span>
<span class="fc" id="L1197">    }</span>

    /** Write the entire buffer to output stream. */
    public void writeTo(final OutputStream out) throws IOException
    {
<span class="fc bfc" id="L1202" title="All 2 branches covered.">        for (int i = 0; i &lt;= index; i++)</span>
        {
<span class="fc" id="L1204">            Block block = blocks.get(i);</span>
<span class="fc" id="L1205">            out.write(block.data, 0, block.limit);</span>
        }
<span class="fc" id="L1207">    }</span>

    /** Write a specific segment of data from the buffer to a stream. */
    public void writeTo(final OutputStream out, long position, long length) throws IOException
    {
<span class="fc bfc" id="L1212" title="All 2 branches covered.">        while (length &gt; 0)</span>
        {
<span class="fc" id="L1214">            final int index = index(position);</span>
<span class="fc" id="L1215">            final int offset = offset(position);</span>
<span class="fc" id="L1216">            final Block block = blocks.get(index);</span>
<span class="fc" id="L1217">            final int amount = (int) Math.min(block.data.length - offset, length);</span>
<span class="fc" id="L1218">            out.write(block.data, offset, amount);</span>

<span class="fc" id="L1220">            position += amount;</span>
<span class="fc" id="L1221">            length -= amount;</span>
<span class="fc" id="L1222">        }</span>
<span class="fc" id="L1223">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>